"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAssetPicomatchMatcher = exports.findAssets = exports.getSourcePaths = exports.getSourceAttribute = exports.resolveAssetFilePath = exports.isHashedAsset = void 0;
const path_1 = __importDefault(require("path"));
const picomatch_1 = __importDefault(require("picomatch"));
const parse5_utils_1 = require("@web/parse5-utils");
const utils_js_1 = require("../utils.js");
const v8_1 = require("v8");
const hashedLinkRels = ['stylesheet'];
const linkRels = [...hashedLinkRels, 'icon', 'manifest', 'apple-touch-icon', 'mask-icon'];
function getSrcSetUrls(srcset) {
    if (!srcset) {
        return [];
    }
    const srcsetParts = srcset.includes(',') ? srcset.split(',') : [srcset];
    const urls = srcsetParts
        .map(url => url.trim())
        .map(url => (url.includes(' ') ? url.split(' ')[0] : url));
    return urls;
}
function extractFirstUrlOfSrcSet(node) {
    const srcset = (0, parse5_utils_1.getAttribute)(node, 'srcset');
    if (!srcset) {
        return '';
    }
    const urls = getSrcSetUrls(srcset);
    return urls[0];
}
function isAsset(node) {
    var _a, _b, _c, _d, _e, _f, _g;
    let path = '';
    switch ((0, parse5_utils_1.getTagName)(node)) {
        case 'img':
            path = (_a = (0, parse5_utils_1.getAttribute)(node, 'src')) !== null && _a !== void 0 ? _a : '';
            break;
        case 'source':
            if ((0, parse5_utils_1.getAttribute)(node, 'src')) {
                path = (_b = (0, parse5_utils_1.getAttribute)(node, 'src')) !== null && _b !== void 0 ? _b : '';
            }
            else {
                path = (_c = extractFirstUrlOfSrcSet(node)) !== null && _c !== void 0 ? _c : '';
            }
            break;
        case 'link':
            if (linkRels.includes((_d = (0, parse5_utils_1.getAttribute)(node, 'rel')) !== null && _d !== void 0 ? _d : '')) {
                path = (_e = (0, parse5_utils_1.getAttribute)(node, 'href')) !== null && _e !== void 0 ? _e : '';
            }
            break;
        case 'meta':
            if ((0, parse5_utils_1.getAttribute)(node, 'property') === 'og:image' && (0, parse5_utils_1.getAttribute)(node, 'content')) {
                path = (_f = (0, parse5_utils_1.getAttribute)(node, 'content')) !== null && _f !== void 0 ? _f : '';
            }
            break;
        case 'script':
            if ((0, parse5_utils_1.getAttribute)(node, 'type') !== 'module' && (0, parse5_utils_1.getAttribute)(node, 'src')) {
                path = (_g = (0, parse5_utils_1.getAttribute)(node, 'src')) !== null && _g !== void 0 ? _g : '';
            }
            break;
        default:
            return false;
    }
    if (!path) {
        return false;
    }
    try {
        new URL(path);
        return false;
    }
    catch (e) {
        return true;
    }
}
function isHashedAsset(node) {
    switch ((0, parse5_utils_1.getTagName)(node)) {
        case 'img':
            return true;
        case 'source':
            return true;
        case 'script':
            return true;
        case 'link':
            return hashedLinkRels.includes((0, parse5_utils_1.getAttribute)(node, 'rel'));
        case 'meta':
            return true;
        default:
            return false;
    }
}
exports.isHashedAsset = isHashedAsset;
function resolveAssetFilePath(browserPath, htmlDir, projectRootDir, absolutePathPrefix) {
    const _browserPath = absolutePathPrefix && browserPath[0] === '/'
        ? '/' + path_1.default.posix.relative(absolutePathPrefix, browserPath)
        : browserPath;
    return path_1.default.join(_browserPath.startsWith('/') ? projectRootDir : htmlDir, _browserPath.split('/').join(path_1.default.sep));
}
exports.resolveAssetFilePath = resolveAssetFilePath;
function getSourceAttribute(node) {
    switch ((0, parse5_utils_1.getTagName)(node)) {
        case 'img': {
            return 'src';
        }
        case 'source': {
            return (0, parse5_utils_1.getAttribute)(node, 'src') ? 'src' : 'srcset';
        }
        case 'link': {
            return 'href';
        }
        case 'script': {
            return 'src';
        }
        case 'meta': {
            return 'content';
        }
        default:
            throw new Error(`Unknown node with tagname ${(0, parse5_utils_1.getTagName)(node)}`);
    }
}
exports.getSourceAttribute = getSourceAttribute;
function getSourcePaths(node) {
    const key = getSourceAttribute(node);
    const src = (0, parse5_utils_1.getAttribute)(node, key);
    if (typeof key !== 'string' || src === '') {
        throw (0, utils_js_1.createError)(`Missing attribute ${key} in element ${(0, v8_1.serialize)(node)}`);
    }
    let paths = [];
    if (src) {
        paths = key !== 'srcset' ? [src] : getSrcSetUrls(src);
    }
    return paths;
}
exports.getSourcePaths = getSourcePaths;
function findAssets(document) {
    return (0, parse5_utils_1.findElements)(document, isAsset);
}
exports.findAssets = findAssets;
// picomatch follows glob spec and requires "./" to be removed for the matcher to work
// it is safe, because with or without it resolves to the same file
// read more: https://github.com/micromatch/picomatch/issues/77
const removeLeadingSlash = (str) => (str.startsWith('./') ? str.slice(2) : str);
function createAssetPicomatchMatcher(glob) {
    return (0, picomatch_1.default)(glob || [], { format: removeLeadingSlash });
}
exports.createAssetPicomatchMatcher = createAssetPicomatchMatcher;
//# sourceMappingURL=utils.js.map