"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.rollupPluginHTML = void 0;
const path_1 = __importDefault(require("path"));
const addRollupInput_js_1 = require("./input/addRollupInput.js");
const getInputData_js_1 = require("./input/getInputData.js");
const createHTMLOutput_js_1 = require("./output/createHTMLOutput.js");
const utils_js_1 = require("./utils.js");
const emitAssets_js_1 = require("./output/emitAssets.js");
function rollupPluginHTML(pluginOptions = {}) {
    const multiOutputNames = [];
    let inputs = [];
    let generatedBundles = [];
    let externalTransformHtmlFns = [];
    let defaultInjectDisabled = false;
    let serviceWorkerPath = '';
    let injectServiceWorker = false;
    let absolutePathPrefix;
    let strictCSPInlineScripts = false;
    function reset() {
        inputs = [];
        generatedBundles = [];
        externalTransformHtmlFns = [];
    }
    return {
        name: '@web/rollup-plugin-html',
        options(inputOptions) {
            reset();
            inputs = (0, getInputData_js_1.getInputData)(pluginOptions, inputOptions.input);
            const moduleImports = [];
            for (const input of inputs) {
                moduleImports.push(...input.moduleImports);
            }
            if (moduleImports.length === 0) {
                // if there are only pages with pure HTML we need to make sure there is at
                // least some input for rollup
                moduleImports.push(utils_js_1.NOOP_IMPORT);
            }
            if (pluginOptions.serviceWorkerPath) {
                serviceWorkerPath = pluginOptions.serviceWorkerPath;
            }
            if (pluginOptions.injectServiceWorker) {
                injectServiceWorker = pluginOptions.injectServiceWorker;
            }
            if (pluginOptions.absolutePathPrefix) {
                absolutePathPrefix = pluginOptions.absolutePathPrefix;
            }
            if (pluginOptions.strictCSPInlineScripts) {
                strictCSPInlineScripts = pluginOptions.strictCSPInlineScripts;
            }
            pluginOptions.bundleAssetsFromCss = !!pluginOptions.bundleAssetsFromCss;
            if (pluginOptions.input == null) {
                // we are reading rollup input, so replace whatever was there
                return Object.assign(Object.assign({}, inputOptions), { input: moduleImports.map(mod => mod.importPath) });
            }
            else {
                // we need to add modules to existing rollup input
                return (0, addRollupInput_js_1.addRollupInput)(inputOptions, moduleImports);
            }
        },
        /** Watch input files when running in watch mode */
        buildStart() {
            // watch filesf
            for (const input of inputs) {
                if (input.filePath) {
                    this.addWatchFile(input.filePath);
                }
                for (const asset of input.assets) {
                    this.addWatchFile(asset.filePath);
                }
            }
        },
        /** Notifies rollup that we will be handling these modules */
        resolveId(id) {
            if (id === utils_js_1.NOOP_IMPORT.importPath) {
                return utils_js_1.NOOP_IMPORT.importPath;
            }
            for (const input of inputs) {
                if (input.inlineModules.find(mod => mod.importPath === id)) {
                    return id;
                }
            }
        },
        /** Provide code for modules we are handling */
        load(id) {
            if (id === utils_js_1.NOOP_IMPORT.importPath) {
                return 'export default "noop"';
            }
            for (const input of inputs) {
                const foundMod = input.inlineModules.find(mod => mod.importPath === id);
                if (foundMod) {
                    return foundMod.code;
                }
            }
        },
        /**
         * Emits output html file if we are doing a single output build.
         * @param {OutputOptions} options
         * @param {OutputBundle} bundle
         */
        async generateBundle(options, bundle) {
            if (multiOutputNames.length !== 0) {
                // we are generating multiple build outputs, which is handled by child plugins
                return;
            }
            if (!options.dir) {
                throw (0, utils_js_1.createError)('Rollup output options must have a dir option set to emit an HTML file.');
            }
            generatedBundles.push({ name: 'default', options, bundle });
            const emittedAssets = await emitAssets_js_1.emitAssets.call(this, inputs, pluginOptions);
            const outputs = await (0, createHTMLOutput_js_1.createHTMLOutput)({
                outputDir: path_1.default.resolve(options.dir),
                inputs,
                emittedAssets,
                generatedBundles,
                externalTransformHtmlFns,
                pluginOptions,
                defaultInjectDisabled,
                serviceWorkerPath,
                injectServiceWorker,
                absolutePathPrefix,
                strictCSPInlineScripts,
            });
            for (const output of outputs) {
                this.emitFile(output);
            }
        },
        api: {
            getInputs() {
                return inputs;
            },
            addHtmlTransformer(transformHtmlFunction) {
                externalTransformHtmlFns.push(transformHtmlFunction);
            },
            disableDefaultInject() {
                defaultInjectDisabled = true;
            },
            addOutput(name) {
                if (!name || multiOutputNames.includes(name)) {
                    throw (0, utils_js_1.createError)('Each output must have a unique name');
                }
                multiOutputNames.push(name);
                return {
                    name: `@web/rollup-plugin-html-multi-output-${multiOutputNames.length}`,
                    async generateBundle(options, bundle) {
                        if (!options.dir) {
                            throw (0, utils_js_1.createError)(`Output ${name} must have a dir option set.`);
                        }
                        generatedBundles.push({ name, options, bundle });
                        if (generatedBundles.length === multiOutputNames.length) {
                            // this is the last build, emit the HTML files
                            const outputDirs = new Set(generatedBundles.map(b => b.options.dir));
                            if (outputDirs.size !== 1) {
                                throw (0, utils_js_1.createError)('Unable to emit HTML output. Multiple rollup build outputs have a different output directory set.');
                            }
                            const emittedAssets = await emitAssets_js_1.emitAssets.call(this, inputs, pluginOptions);
                            const outputs = await (0, createHTMLOutput_js_1.createHTMLOutput)({
                                outputDir: path_1.default.resolve(options.dir),
                                inputs,
                                emittedAssets,
                                generatedBundles,
                                externalTransformHtmlFns,
                                pluginOptions,
                                defaultInjectDisabled,
                                serviceWorkerPath,
                                injectServiceWorker,
                                absolutePathPrefix,
                                strictCSPInlineScripts,
                            });
                            for (const output of outputs) {
                                this.emitFile(output);
                            }
                        }
                    },
                };
            },
        },
    };
}
exports.rollupPluginHTML = rollupPluginHTML;
//# sourceMappingURL=rollupPluginHTML.js.map